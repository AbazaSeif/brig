// Code generated by capnpc-go. DO NOT EDIT.

package capnp

import (
	strconv "strconv"
	capnp "zombiezen.com/go/capnproto2"
	text "zombiezen.com/go/capnproto2/encoding/text"
	schemas "zombiezen.com/go/capnproto2/schemas"
)

// Person might be any brig user
type Person struct{ capnp.Struct }

// Person_TypeID is the unique identifier for the type Person.
const Person_TypeID = 0xf736dd278ea58545

func NewPerson(s *capnp.Segment) (Person, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Person{st}, err
}

func NewRootPerson(s *capnp.Segment) (Person, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Person{st}, err
}

func ReadRootPerson(msg *capnp.Message) (Person, error) {
	root, err := msg.RootPtr()
	return Person{root.Struct()}, err
}

func (s Person) String() string {
	str, _ := text.Marshal(0xf736dd278ea58545, s.Struct)
	return str
}

func (s Person) Ident() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Person) HasIdent() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Person) IdentBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Person) SetIdent(v string) error {
	return s.Struct.SetText(0, v)
}

func (s Person) Hash() ([]byte, error) {
	p, err := s.Struct.Ptr(1)
	return []byte(p.Data()), err
}

func (s Person) HasHash() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Person) SetHash(v []byte) error {
	return s.Struct.SetData(1, v)
}

// Person_List is a list of Person.
type Person_List struct{ capnp.List }

// NewPerson creates a new list of Person.
func NewPerson_List(s *capnp.Segment, sz int32) (Person_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return Person_List{l}, err
}

func (s Person_List) At(i int) Person { return Person{s.List.Struct(i)} }

func (s Person_List) Set(i int, v Person) error { return s.List.SetStruct(i, v.Struct) }

func (s Person_List) String() string {
	str, _ := text.MarshalList(0xf736dd278ea58545, s.List)
	return str
}

// Person_Promise is a wrapper for a Person promised by a client call.
type Person_Promise struct{ *capnp.Pipeline }

func (p Person_Promise) Struct() (Person, error) {
	s, err := p.Pipeline.Struct()
	return Person{s}, err
}

// Commit is a set of changes to nodes
type Commit struct{ capnp.Struct }
type Commit_merge Commit

// Commit_TypeID is the unique identifier for the type Commit.
const Commit_TypeID = 0x8da013c66e545daf

func NewCommit(s *capnp.Segment) (Commit, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 6})
	return Commit{st}, err
}

func NewRootCommit(s *capnp.Segment) (Commit, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 6})
	return Commit{st}, err
}

func ReadRootCommit(msg *capnp.Message) (Commit, error) {
	root, err := msg.RootPtr()
	return Commit{root.Struct()}, err
}

func (s Commit) String() string {
	str, _ := text.Marshal(0x8da013c66e545daf, s.Struct)
	return str
}

func (s Commit) Message() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Commit) HasMessage() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Commit) MessageBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Commit) SetMessage(v string) error {
	return s.Struct.SetText(0, v)
}

func (s Commit) Author() (Person, error) {
	p, err := s.Struct.Ptr(1)
	return Person{Struct: p.Struct()}, err
}

func (s Commit) HasAuthor() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Commit) SetAuthor(v Person) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewAuthor sets the author field to a newly
// allocated Person struct, preferring placement in s's segment.
func (s Commit) NewAuthor() (Person, error) {
	ss, err := NewPerson(s.Struct.Segment())
	if err != nil {
		return Person{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s Commit) Parent() ([]byte, error) {
	p, err := s.Struct.Ptr(2)
	return []byte(p.Data()), err
}

func (s Commit) HasParent() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s Commit) SetParent(v []byte) error {
	return s.Struct.SetData(2, v)
}

func (s Commit) Root() ([]byte, error) {
	p, err := s.Struct.Ptr(3)
	return []byte(p.Data()), err
}

func (s Commit) HasRoot() bool {
	p, err := s.Struct.Ptr(3)
	return p.IsValid() || err != nil
}

func (s Commit) SetRoot(v []byte) error {
	return s.Struct.SetData(3, v)
}

func (s Commit) Merge() Commit_merge { return Commit_merge(s) }

func (s Commit_merge) IsMerge() bool {
	return s.Struct.Bit(0)
}

func (s Commit_merge) SetIsMerge(v bool) {
	s.Struct.SetBit(0, v)
}

func (s Commit_merge) With() (Person, error) {
	p, err := s.Struct.Ptr(4)
	return Person{Struct: p.Struct()}, err
}

func (s Commit_merge) HasWith() bool {
	p, err := s.Struct.Ptr(4)
	return p.IsValid() || err != nil
}

func (s Commit_merge) SetWith(v Person) error {
	return s.Struct.SetPtr(4, v.Struct.ToPtr())
}

// NewWith sets the with field to a newly
// allocated Person struct, preferring placement in s's segment.
func (s Commit_merge) NewWith() (Person, error) {
	ss, err := NewPerson(s.Struct.Segment())
	if err != nil {
		return Person{}, err
	}
	err = s.Struct.SetPtr(4, ss.Struct.ToPtr())
	return ss, err
}

func (s Commit_merge) Hash() ([]byte, error) {
	p, err := s.Struct.Ptr(5)
	return []byte(p.Data()), err
}

func (s Commit_merge) HasHash() bool {
	p, err := s.Struct.Ptr(5)
	return p.IsValid() || err != nil
}

func (s Commit_merge) SetHash(v []byte) error {
	return s.Struct.SetData(5, v)
}

// Commit_List is a list of Commit.
type Commit_List struct{ capnp.List }

// NewCommit creates a new list of Commit.
func NewCommit_List(s *capnp.Segment, sz int32) (Commit_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 6}, sz)
	return Commit_List{l}, err
}

func (s Commit_List) At(i int) Commit { return Commit{s.List.Struct(i)} }

func (s Commit_List) Set(i int, v Commit) error { return s.List.SetStruct(i, v.Struct) }

func (s Commit_List) String() string {
	str, _ := text.MarshalList(0x8da013c66e545daf, s.List)
	return str
}

// Commit_Promise is a wrapper for a Commit promised by a client call.
type Commit_Promise struct{ *capnp.Pipeline }

func (p Commit_Promise) Struct() (Commit, error) {
	s, err := p.Pipeline.Struct()
	return Commit{s}, err
}

func (p Commit_Promise) Author() Person_Promise {
	return Person_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p Commit_Promise) Merge() Commit_merge_Promise { return Commit_merge_Promise{p.Pipeline} }

// Commit_merge_Promise is a wrapper for a Commit_merge promised by a client call.
type Commit_merge_Promise struct{ *capnp.Pipeline }

func (p Commit_merge_Promise) Struct() (Commit_merge, error) {
	s, err := p.Pipeline.Struct()
	return Commit_merge{s}, err
}

func (p Commit_merge_Promise) With() Person_Promise {
	return Person_Promise{Pipeline: p.Pipeline.GetPipeline(4)}
}

// A single directory entry
type DirEntry struct{ capnp.Struct }

// DirEntry_TypeID is the unique identifier for the type DirEntry.
const DirEntry_TypeID = 0x8b15ee76774b1f9d

func NewDirEntry(s *capnp.Segment) (DirEntry, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return DirEntry{st}, err
}

func NewRootDirEntry(s *capnp.Segment) (DirEntry, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return DirEntry{st}, err
}

func ReadRootDirEntry(msg *capnp.Message) (DirEntry, error) {
	root, err := msg.RootPtr()
	return DirEntry{root.Struct()}, err
}

func (s DirEntry) String() string {
	str, _ := text.Marshal(0x8b15ee76774b1f9d, s.Struct)
	return str
}

func (s DirEntry) Name() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s DirEntry) HasName() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s DirEntry) NameBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s DirEntry) SetName(v string) error {
	return s.Struct.SetText(0, v)
}

func (s DirEntry) Hash() ([]byte, error) {
	p, err := s.Struct.Ptr(1)
	return []byte(p.Data()), err
}

func (s DirEntry) HasHash() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s DirEntry) SetHash(v []byte) error {
	return s.Struct.SetData(1, v)
}

// DirEntry_List is a list of DirEntry.
type DirEntry_List struct{ capnp.List }

// NewDirEntry creates a new list of DirEntry.
func NewDirEntry_List(s *capnp.Segment, sz int32) (DirEntry_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return DirEntry_List{l}, err
}

func (s DirEntry_List) At(i int) DirEntry { return DirEntry{s.List.Struct(i)} }

func (s DirEntry_List) Set(i int, v DirEntry) error { return s.List.SetStruct(i, v.Struct) }

func (s DirEntry_List) String() string {
	str, _ := text.MarshalList(0x8b15ee76774b1f9d, s.List)
	return str
}

// DirEntry_Promise is a wrapper for a DirEntry promised by a client call.
type DirEntry_Promise struct{ *capnp.Pipeline }

func (p DirEntry_Promise) Struct() (DirEntry, error) {
	s, err := p.Pipeline.Struct()
	return DirEntry{s}, err
}

// Directory contains one or more directories or files
type Directory struct{ capnp.Struct }

// Directory_TypeID is the unique identifier for the type Directory.
const Directory_TypeID = 0xe24c59306c829c01

func NewDirectory(s *capnp.Segment) (Directory, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Directory{st}, err
}

func NewRootDirectory(s *capnp.Segment) (Directory, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Directory{st}, err
}

func ReadRootDirectory(msg *capnp.Message) (Directory, error) {
	root, err := msg.RootPtr()
	return Directory{root.Struct()}, err
}

func (s Directory) String() string {
	str, _ := text.Marshal(0xe24c59306c829c01, s.Struct)
	return str
}

func (s Directory) Size() uint64 {
	return s.Struct.Uint64(0)
}

func (s Directory) SetSize(v uint64) {
	s.Struct.SetUint64(0, v)
}

func (s Directory) Parent() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Directory) HasParent() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Directory) ParentBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Directory) SetParent(v string) error {
	return s.Struct.SetText(0, v)
}

func (s Directory) Children() (DirEntry_List, error) {
	p, err := s.Struct.Ptr(1)
	return DirEntry_List{List: p.List()}, err
}

func (s Directory) HasChildren() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Directory) SetChildren(v DirEntry_List) error {
	return s.Struct.SetPtr(1, v.List.ToPtr())
}

// NewChildren sets the children field to a newly
// allocated DirEntry_List, preferring placement in s's segment.
func (s Directory) NewChildren(n int32) (DirEntry_List, error) {
	l, err := NewDirEntry_List(s.Struct.Segment(), n)
	if err != nil {
		return DirEntry_List{}, err
	}
	err = s.Struct.SetPtr(1, l.List.ToPtr())
	return l, err
}

// Directory_List is a list of Directory.
type Directory_List struct{ capnp.List }

// NewDirectory creates a new list of Directory.
func NewDirectory_List(s *capnp.Segment, sz int32) (Directory_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return Directory_List{l}, err
}

func (s Directory_List) At(i int) Directory { return Directory{s.List.Struct(i)} }

func (s Directory_List) Set(i int, v Directory) error { return s.List.SetStruct(i, v.Struct) }

func (s Directory_List) String() string {
	str, _ := text.MarshalList(0xe24c59306c829c01, s.List)
	return str
}

// Directory_Promise is a wrapper for a Directory promised by a client call.
type Directory_Promise struct{ *capnp.Pipeline }

func (p Directory_Promise) Struct() (Directory, error) {
	s, err := p.Pipeline.Struct()
	return Directory{s}, err
}

// A leaf node in the MDAG
type File struct{ capnp.Struct }

// File_TypeID is the unique identifier for the type File.
const File_TypeID = 0x8ea7393d37893155

func NewFile(s *capnp.Segment) (File, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 3})
	return File{st}, err
}

func NewRootFile(s *capnp.Segment) (File, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 3})
	return File{st}, err
}

func ReadRootFile(msg *capnp.Message) (File, error) {
	root, err := msg.RootPtr()
	return File{root.Struct()}, err
}

func (s File) String() string {
	str, _ := text.Marshal(0x8ea7393d37893155, s.Struct)
	return str
}

func (s File) Size() uint64 {
	return s.Struct.Uint64(0)
}

func (s File) SetSize(v uint64) {
	s.Struct.SetUint64(0, v)
}

func (s File) Parent() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s File) HasParent() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s File) ParentBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s File) SetParent(v string) error {
	return s.Struct.SetText(0, v)
}

func (s File) Key() ([]byte, error) {
	p, err := s.Struct.Ptr(1)
	return []byte(p.Data()), err
}

func (s File) HasKey() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s File) SetKey(v []byte) error {
	return s.Struct.SetData(1, v)
}

func (s File) Content() ([]byte, error) {
	p, err := s.Struct.Ptr(2)
	return []byte(p.Data()), err
}

func (s File) HasContent() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s File) SetContent(v []byte) error {
	return s.Struct.SetData(2, v)
}

// File_List is a list of File.
type File_List struct{ capnp.List }

// NewFile creates a new list of File.
func NewFile_List(s *capnp.Segment, sz int32) (File_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 3}, sz)
	return File_List{l}, err
}

func (s File_List) At(i int) File { return File{s.List.Struct(i)} }

func (s File_List) Set(i int, v File) error { return s.List.SetStruct(i, v.Struct) }

func (s File_List) String() string {
	str, _ := text.MarshalList(0x8ea7393d37893155, s.List)
	return str
}

// File_Promise is a wrapper for a File promised by a client call.
type File_Promise struct{ *capnp.Pipeline }

func (p File_Promise) Struct() (File, error) {
	s, err := p.Pipeline.Struct()
	return File{s}, err
}

// Ghost indicates that a certain node was at this path once
type Ghost struct{ capnp.Struct }
type Ghost_Which uint16

const (
	Ghost_Which_commit    Ghost_Which = 0
	Ghost_Which_directory Ghost_Which = 1
	Ghost_Which_file      Ghost_Which = 2
)

func (w Ghost_Which) String() string {
	const s = "commitdirectoryfile"
	switch w {
	case Ghost_Which_commit:
		return s[0:6]
	case Ghost_Which_directory:
		return s[6:15]
	case Ghost_Which_file:
		return s[15:19]

	}
	return "Ghost_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Ghost_TypeID is the unique identifier for the type Ghost.
const Ghost_TypeID = 0x80c828d7e89c12ea

func NewGhost(s *capnp.Segment) (Ghost, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return Ghost{st}, err
}

func NewRootGhost(s *capnp.Segment) (Ghost, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return Ghost{st}, err
}

func ReadRootGhost(msg *capnp.Message) (Ghost, error) {
	root, err := msg.RootPtr()
	return Ghost{root.Struct()}, err
}

func (s Ghost) String() string {
	str, _ := text.Marshal(0x80c828d7e89c12ea, s.Struct)
	return str
}

func (s Ghost) Which() Ghost_Which {
	return Ghost_Which(s.Struct.Uint16(8))
}
func (s Ghost) GhostInode() uint64 {
	return s.Struct.Uint64(0)
}

func (s Ghost) SetGhostInode(v uint64) {
	s.Struct.SetUint64(0, v)
}

func (s Ghost) Commit() (Commit, error) {
	p, err := s.Struct.Ptr(0)
	return Commit{Struct: p.Struct()}, err
}

func (s Ghost) HasCommit() bool {
	if s.Struct.Uint16(8) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Ghost) SetCommit(v Commit) error {
	s.Struct.SetUint16(8, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewCommit sets the commit field to a newly
// allocated Commit struct, preferring placement in s's segment.
func (s Ghost) NewCommit() (Commit, error) {
	s.Struct.SetUint16(8, 0)
	ss, err := NewCommit(s.Struct.Segment())
	if err != nil {
		return Commit{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Ghost) Directory() (Directory, error) {
	p, err := s.Struct.Ptr(0)
	return Directory{Struct: p.Struct()}, err
}

func (s Ghost) HasDirectory() bool {
	if s.Struct.Uint16(8) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Ghost) SetDirectory(v Directory) error {
	s.Struct.SetUint16(8, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDirectory sets the directory field to a newly
// allocated Directory struct, preferring placement in s's segment.
func (s Ghost) NewDirectory() (Directory, error) {
	s.Struct.SetUint16(8, 1)
	ss, err := NewDirectory(s.Struct.Segment())
	if err != nil {
		return Directory{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Ghost) File() (File, error) {
	p, err := s.Struct.Ptr(0)
	return File{Struct: p.Struct()}, err
}

func (s Ghost) HasFile() bool {
	if s.Struct.Uint16(8) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Ghost) SetFile(v File) error {
	s.Struct.SetUint16(8, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewFile sets the file field to a newly
// allocated File struct, preferring placement in s's segment.
func (s Ghost) NewFile() (File, error) {
	s.Struct.SetUint16(8, 2)
	ss, err := NewFile(s.Struct.Segment())
	if err != nil {
		return File{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// Ghost_List is a list of Ghost.
type Ghost_List struct{ capnp.List }

// NewGhost creates a new list of Ghost.
func NewGhost_List(s *capnp.Segment, sz int32) (Ghost_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1}, sz)
	return Ghost_List{l}, err
}

func (s Ghost_List) At(i int) Ghost { return Ghost{s.List.Struct(i)} }

func (s Ghost_List) Set(i int, v Ghost) error { return s.List.SetStruct(i, v.Struct) }

func (s Ghost_List) String() string {
	str, _ := text.MarshalList(0x80c828d7e89c12ea, s.List)
	return str
}

// Ghost_Promise is a wrapper for a Ghost promised by a client call.
type Ghost_Promise struct{ *capnp.Pipeline }

func (p Ghost_Promise) Struct() (Ghost, error) {
	s, err := p.Pipeline.Struct()
	return Ghost{s}, err
}

func (p Ghost_Promise) Commit() Commit_Promise {
	return Commit_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Ghost_Promise) Directory() Directory_Promise {
	return Directory_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Ghost_Promise) File() File_Promise {
	return File_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

// Node is a node in the merkle dag of brig
type Node struct{ capnp.Struct }
type Node_Which uint16

const (
	Node_Which_commit    Node_Which = 0
	Node_Which_directory Node_Which = 1
	Node_Which_file      Node_Which = 2
	Node_Which_ghost     Node_Which = 3
)

func (w Node_Which) String() string {
	const s = "commitdirectoryfileghost"
	switch w {
	case Node_Which_commit:
		return s[0:6]
	case Node_Which_directory:
		return s[6:15]
	case Node_Which_file:
		return s[15:19]
	case Node_Which_ghost:
		return s[19:24]

	}
	return "Node_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Node_TypeID is the unique identifier for the type Node.
const Node_TypeID = 0xa629eb7f7066fae3

func NewNode(s *capnp.Segment) (Node, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 4})
	return Node{st}, err
}

func NewRootNode(s *capnp.Segment) (Node, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 4})
	return Node{st}, err
}

func ReadRootNode(msg *capnp.Message) (Node, error) {
	root, err := msg.RootPtr()
	return Node{root.Struct()}, err
}

func (s Node) String() string {
	str, _ := text.Marshal(0xa629eb7f7066fae3, s.Struct)
	return str
}

func (s Node) Which() Node_Which {
	return Node_Which(s.Struct.Uint16(8))
}
func (s Node) Name() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Node) HasName() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Node) NameBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Node) SetName(v string) error {
	return s.Struct.SetText(0, v)
}

func (s Node) Hash() ([]byte, error) {
	p, err := s.Struct.Ptr(1)
	return []byte(p.Data()), err
}

func (s Node) HasHash() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Node) SetHash(v []byte) error {
	return s.Struct.SetData(1, v)
}

func (s Node) ModTime() (string, error) {
	p, err := s.Struct.Ptr(2)
	return p.Text(), err
}

func (s Node) HasModTime() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s Node) ModTimeBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(2)
	return p.TextBytes(), err
}

func (s Node) SetModTime(v string) error {
	return s.Struct.SetText(2, v)
}

func (s Node) Inode() uint64 {
	return s.Struct.Uint64(0)
}

func (s Node) SetInode(v uint64) {
	s.Struct.SetUint64(0, v)
}

func (s Node) Commit() (Commit, error) {
	p, err := s.Struct.Ptr(3)
	return Commit{Struct: p.Struct()}, err
}

func (s Node) HasCommit() bool {
	if s.Struct.Uint16(8) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(3)
	return p.IsValid() || err != nil
}

func (s Node) SetCommit(v Commit) error {
	s.Struct.SetUint16(8, 0)
	return s.Struct.SetPtr(3, v.Struct.ToPtr())
}

// NewCommit sets the commit field to a newly
// allocated Commit struct, preferring placement in s's segment.
func (s Node) NewCommit() (Commit, error) {
	s.Struct.SetUint16(8, 0)
	ss, err := NewCommit(s.Struct.Segment())
	if err != nil {
		return Commit{}, err
	}
	err = s.Struct.SetPtr(3, ss.Struct.ToPtr())
	return ss, err
}

func (s Node) Directory() (Directory, error) {
	p, err := s.Struct.Ptr(3)
	return Directory{Struct: p.Struct()}, err
}

func (s Node) HasDirectory() bool {
	if s.Struct.Uint16(8) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(3)
	return p.IsValid() || err != nil
}

func (s Node) SetDirectory(v Directory) error {
	s.Struct.SetUint16(8, 1)
	return s.Struct.SetPtr(3, v.Struct.ToPtr())
}

// NewDirectory sets the directory field to a newly
// allocated Directory struct, preferring placement in s's segment.
func (s Node) NewDirectory() (Directory, error) {
	s.Struct.SetUint16(8, 1)
	ss, err := NewDirectory(s.Struct.Segment())
	if err != nil {
		return Directory{}, err
	}
	err = s.Struct.SetPtr(3, ss.Struct.ToPtr())
	return ss, err
}

func (s Node) File() (File, error) {
	p, err := s.Struct.Ptr(3)
	return File{Struct: p.Struct()}, err
}

func (s Node) HasFile() bool {
	if s.Struct.Uint16(8) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(3)
	return p.IsValid() || err != nil
}

func (s Node) SetFile(v File) error {
	s.Struct.SetUint16(8, 2)
	return s.Struct.SetPtr(3, v.Struct.ToPtr())
}

// NewFile sets the file field to a newly
// allocated File struct, preferring placement in s's segment.
func (s Node) NewFile() (File, error) {
	s.Struct.SetUint16(8, 2)
	ss, err := NewFile(s.Struct.Segment())
	if err != nil {
		return File{}, err
	}
	err = s.Struct.SetPtr(3, ss.Struct.ToPtr())
	return ss, err
}

func (s Node) Ghost() (Ghost, error) {
	p, err := s.Struct.Ptr(3)
	return Ghost{Struct: p.Struct()}, err
}

func (s Node) HasGhost() bool {
	if s.Struct.Uint16(8) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(3)
	return p.IsValid() || err != nil
}

func (s Node) SetGhost(v Ghost) error {
	s.Struct.SetUint16(8, 3)
	return s.Struct.SetPtr(3, v.Struct.ToPtr())
}

// NewGhost sets the ghost field to a newly
// allocated Ghost struct, preferring placement in s's segment.
func (s Node) NewGhost() (Ghost, error) {
	s.Struct.SetUint16(8, 3)
	ss, err := NewGhost(s.Struct.Segment())
	if err != nil {
		return Ghost{}, err
	}
	err = s.Struct.SetPtr(3, ss.Struct.ToPtr())
	return ss, err
}

// Node_List is a list of Node.
type Node_List struct{ capnp.List }

// NewNode creates a new list of Node.
func NewNode_List(s *capnp.Segment, sz int32) (Node_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 4}, sz)
	return Node_List{l}, err
}

func (s Node_List) At(i int) Node { return Node{s.List.Struct(i)} }

func (s Node_List) Set(i int, v Node) error { return s.List.SetStruct(i, v.Struct) }

func (s Node_List) String() string {
	str, _ := text.MarshalList(0xa629eb7f7066fae3, s.List)
	return str
}

// Node_Promise is a wrapper for a Node promised by a client call.
type Node_Promise struct{ *capnp.Pipeline }

func (p Node_Promise) Struct() (Node, error) {
	s, err := p.Pipeline.Struct()
	return Node{s}, err
}

func (p Node_Promise) Commit() Commit_Promise {
	return Commit_Promise{Pipeline: p.Pipeline.GetPipeline(3)}
}

func (p Node_Promise) Directory() Directory_Promise {
	return Directory_Promise{Pipeline: p.Pipeline.GetPipeline(3)}
}

func (p Node_Promise) File() File_Promise {
	return File_Promise{Pipeline: p.Pipeline.GetPipeline(3)}
}

func (p Node_Promise) Ghost() Ghost_Promise {
	return Ghost_Promise{Pipeline: p.Pipeline.GetPipeline(3)}
}

const schema_9195d073cb5c5953 = "x\xda\xb4U]\x88Te\x1f\xff\xff\x9e\xe7\xcc\x9c\x1d" +
	"\xd8yw\x8eg\x17\xde\x17\xdee\x1e\xc4\x97W%\xcd" +
	"/*\x17d]\xdb\xcd\xd6\\\xd9\xa7\xf4\xc2\xb0\xe88" +
	"\xf3\xec\x9c\x833\xe7\x0c\xe7\x1c[7\x94\xb5P\xc8J" +
	")\xc2\x8b\xc0H\x82\x0c\xba\xf1^\xe8F\xe8\x03\xeb\xc2" +
	"\xa2\x0f\x0d\x852%\xe9C*\x82B\xd2\x13\xcf\x9c\xd9" +
	"\x99\xd1f\xad\x9b.\xe7\x7f\xfe\xf3\x9c\xdf\xd7\xf3;+" +
	"\xae\xb1\xf5lef\xd6 \x92k2\xd9\xe4\xdb\x05\xc7" +
	"\xae~\xbe\xf8\xfd\xfd$\x17\x80%\x8fl\xdf\xf1At" +
	"\xf6\xe8K4\x06\x93\xc3\xb0\xff\xc7N\xdb\xcb\x98i/" +
	"cE\xdbc\xdf\x10\x92W\x8b\x0fM?ym\xe0y" +
	"\xb2\x16\xa0\xbd\x9ea&\x91=\xc6\xbf\xb0%7m\xc9" +
	"\x8b\xf6>>MHN>\xb6\xd5\x7f\xd7>~X\x9f" +
	"\xde\xb9\x9e\xd5\xeb\xe7\xf9\x19\xfb\x0a7\xed+\xbc\xb8z" +
	"\xc0(\x82\x90l[y\xe8\xdeuk\xdf<r\xfb>" +
	"\xd7\xfb\xb9\xcc)\xdb\xca\x98\xb6\x95)\xdak3\x1a\xcc" +
	"\xd7\xd7\xa7\xea\xb3\xdf-9q;x\xc34`\xd8\xf9" +
	"\xec){ k\xda\x03\xd9\xe2\xea\xf1\xec{\xfa|\x1c" +
	"{\xa6\xbab\xfb\xe6K\xb7\x9f\xdf\x80o\xf5\\\xb2\x07" +
	"{L{\xb0\xa7ho\xeb9IH\xc6\x0e\xbeq\xe4" +
	"\xff\x17\xef\xf9\xb5\x1bY\xe4\xce\xd8\xf9\x9ci\xe7sE" +
	"{mN\x93=\x9e{\xeb\xc4\xe5u\xe1u\x92\xffA" +
	"\x07\xf5\x81\xac\x09\"\xfbh\xee:\xc1~%w\x92\xee" +
	"KJN\xdd\xaf\xdf]\x0bXYU\x977~\x0cm" +
	"t\x83(\xa6I@\x1a`\xc9\xe3/\xbf&\xdf\xfe\xec" +
	"\xb9wH\x1a\x0c#w\x01\xbdD+\xf11\x92\xc6\x9a" +
	"\xf0\xfcl\xd9+9\xb1\x8aD\xec:\xb1pDI\x85" +
	"\xb1\xe3\xf9\xc2\x0f\xcaJL;\x91pb\x11\xbb^$" +
	"\xeaN\xec\x8a\xc0/A\x11\xc9\x027\x88\x0c\x10Y\xce" +
	"\xa3D\xf2\x09\x0eYe\xc8#I\xfa\xa1\xa7\xde\x10\x91" +
	",s\xc8:C\x9e\xddL\xfa\xc1\x88\xac\xda\xc3D\xb2" +
	"\xca!\xf70\xe4\xf9\x8d\xa4\x1f\x9c\xc8\xda\xbd\x94H\xd6" +
	"9\xe4^\x86\xa4\xa2a\x8d\xfb\x01\xf1\xb2B\x8e\x18r" +
	"\x84\xe1RP\xaby1\x0am)\x08(\x10\x92\xb2\x17" +
	"\xaaR\x1c\x84\x84\x19\x14\xda\x9e\xa4O\xfb\xa6\xbc\xaaB" +
	"\xa1\x1d\x85\xe6\x9f\xbah6\xea\x85c~\xcc\xc3\x99\xee" +
	"\xb2\xfd\xb7!\x9b\x853\xc9\x88\x88<\xbfRUL\xcc" +
	"\xbdzF(?\x0eg\x08\xb2\xa7\xa5\xc9\x12\xcdh\x11" +
	"\x87\\\xc1`\x01\xa9$\xcb\xf4p1\x87\\\xc3\xd0\xe7" +
	";5\x85^b\xe8%\xf4\xb9N\xe4\"O\x0c\xf9\xee" +
	"\xe8\xeeo\xd0\xa7y<\x15MO\x17\"I\x17\x85\xc7" +
	"#\xe1\x88H\xc5\"\x98\x12%\xd7\xf1+\xda\xde@\xf8" +
	"\x81YV\x11\x91\xeco!\xdd\xb7\x81H\xee\xe1\x90\x07" +
	":\x90>\xad\xcd\xdb\xcb!\x9fe\xb0\x18K\xbd;\xa8" +
	"\x87\xfb9\xe4\x0b\x0c\x16\xe7\xa9u\x874\xa7\x03\x1c\xf2" +
	"E\x06\x18\xe8H\xaeux\x15\xb1\xd9\x9a\x8a\"\xa7\xd2" +
	"b:\xec\xec\x8e\xdd D\xa1}\x1fRO\x86\xebN" +
	"\xa8\xfcxN\x84\xbe0\x08Z?\x8a5\x15VTK" +
	"\x17\xcc\xe92\\\x1fz\xc0\xab\xaa\xee\xa2\xfc\xbb\xe9\xd8" +
	"\xe9dDT\x953%|\xa6\xf3\xec\xf9\"v\x95\x98" +
	"\x18\x1d\xd9H\xb7\xa6X\x13\xd9\xc1!]\x869\x19\xd4" +
	"P;\xd9\x16C*\x83\xb7\xb0\x1dl\x8b\xb3T\x86\x9a" +
	"V\xd1\xe5\x901C_\xe4=\xd5Nn\x93W\x93\xbf" +
	"\xb9K\xcd\xcc\xd1\x9a-\x05~\xdc\xc1\xb9+\xc1-A" +
	"y\x1e\x82\x8b\x9a\xaeoB\xb2\xa5\xc1,\x12\x86\x93^" +
	"\xda&\xc9\x9a\x0awU\x95(;\x15\x1d\x83\x9d\xa1W" +
	"!H\xd1b\xfc\x91f\xfc!\x87<\xd7\xe1\xfc\xa7z" +
	"x\x96C^\xe8p\xfe\xbcf\xf7\x09\x87\xfc\x92\x01M" +
	"\xe3/\xae\"\x92\xe78\xe4e\x86A#Ix?\x0c" +
	"\"\xeb+-\xd9\x05\x0ey\x95a0sS\x8f3D" +
	"\xd6\x15}\xef/s\xc8\x1f\x19\x06\xb37\xf48Kd" +
	"\xfd\xa0\xdfv\x95C\xfe\xc20h\xfe\xae\xc7&\x91\xf5" +
	"\x93>\xfb{\x0e\xf9\xdb\x9d.\xcal-(o\xf5\xda" +
	"\x0f\x8b\x9e&\xff\xcfTF\xb1\xd1J(\xb4\xbfqw" +
	"\xac\x12U\x8a\xcd`\xbe.Y\xdc4\xeeu$\xa3M" +
	"(\x99\x19\xa1\xc3\xe0x~$\x02_\x89 \x14\xb5 " +
	"T\xad\x8a\xf1T\xa4gS\x9eYm\\\xdf\xde\x96\x89" +
	"cZ\xc1\xf5\x1crs;\xb6\xe3\xda\x83Q\x0e9\xd9" +
	"\x11\xdb\x89MDrs\x9a\xef;%4)\xb9^\xb5" +
	"\x1c*\x9f\x88\xf0/\xc2$\x07\x0a\xedO5A\x0f\xbb" +
	"\xd1\x9eTa\x14\xf8\xf3u\xd4\\\x81\xfe\x9c\xa4{\xa2" +
	"\xc6\xbc\x8a\x1b\x8b\x9dJ8\xfeL#\x9cE\xb1;R" +
	"!Qg\x8d\xae\xfa\x8b\x1a-z\xe5\x0e\xec\x7f\xb3G" +
	"\x87\x977\x0a%U1\x8d\xed\xd8\x86\xb6\x8c\x16\x8c4" +
	"\xb4\xe3K;u\xcc\xa4\x91\x9d\xd0\xc3\x079\xe4V\x86" +
	"Y/\x9a\xd0'\x01\xc4\x00B\xdf\xb4\x17\xbb\x7f\xee\xb6" +
	"[`\xfd\x11\x00\x00\xff\xffu\x1dH\x07"

func init() {
	schemas.Register(schema_9195d073cb5c5953,
		0x80c828d7e89c12ea,
		0x8b15ee76774b1f9d,
		0x8da013c66e545daf,
		0x8ea7393d37893155,
		0xa629eb7f7066fae3,
		0xe24c59306c829c01,
		0xf736dd278ea58545,
		0xfa723de4a6aa09a0)
}
