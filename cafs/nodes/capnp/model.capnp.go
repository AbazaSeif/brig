// Code generated by capnpc-go. DO NOT EDIT.

package capnp

import (
	strconv "strconv"
	capnp "zombiezen.com/go/capnproto2"
	text "zombiezen.com/go/capnproto2/encoding/text"
	schemas "zombiezen.com/go/capnproto2/schemas"
)

// Person might be any brig user
type Person struct{ capnp.Struct }

// Person_TypeID is the unique identifier for the type Person.
const Person_TypeID = 0xf736dd278ea58545

func NewPerson(s *capnp.Segment) (Person, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Person{st}, err
}

func NewRootPerson(s *capnp.Segment) (Person, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Person{st}, err
}

func ReadRootPerson(msg *capnp.Message) (Person, error) {
	root, err := msg.RootPtr()
	return Person{root.Struct()}, err
}

func (s Person) String() string {
	str, _ := text.Marshal(0xf736dd278ea58545, s.Struct)
	return str
}

func (s Person) Ident() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Person) HasIdent() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Person) IdentBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Person) SetIdent(v string) error {
	return s.Struct.SetText(0, v)
}

func (s Person) Hash() ([]byte, error) {
	p, err := s.Struct.Ptr(1)
	return []byte(p.Data()), err
}

func (s Person) HasHash() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Person) SetHash(v []byte) error {
	return s.Struct.SetData(1, v)
}

// Person_List is a list of Person.
type Person_List struct{ capnp.List }

// NewPerson creates a new list of Person.
func NewPerson_List(s *capnp.Segment, sz int32) (Person_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return Person_List{l}, err
}

func (s Person_List) At(i int) Person { return Person{s.List.Struct(i)} }

func (s Person_List) Set(i int, v Person) error { return s.List.SetStruct(i, v.Struct) }

func (s Person_List) String() string {
	str, _ := text.MarshalList(0xf736dd278ea58545, s.List)
	return str
}

// Person_Promise is a wrapper for a Person promised by a client call.
type Person_Promise struct{ *capnp.Pipeline }

func (p Person_Promise) Struct() (Person, error) {
	s, err := p.Pipeline.Struct()
	return Person{s}, err
}

// Commit is a set of changes to nodes
type Commit struct{ capnp.Struct }
type Commit_merge Commit

// Commit_TypeID is the unique identifier for the type Commit.
const Commit_TypeID = 0x8da013c66e545daf

func NewCommit(s *capnp.Segment) (Commit, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 6})
	return Commit{st}, err
}

func NewRootCommit(s *capnp.Segment) (Commit, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 6})
	return Commit{st}, err
}

func ReadRootCommit(msg *capnp.Message) (Commit, error) {
	root, err := msg.RootPtr()
	return Commit{root.Struct()}, err
}

func (s Commit) String() string {
	str, _ := text.Marshal(0x8da013c66e545daf, s.Struct)
	return str
}

func (s Commit) Message() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Commit) HasMessage() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Commit) MessageBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Commit) SetMessage(v string) error {
	return s.Struct.SetText(0, v)
}

func (s Commit) Author() (Person, error) {
	p, err := s.Struct.Ptr(1)
	return Person{Struct: p.Struct()}, err
}

func (s Commit) HasAuthor() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Commit) SetAuthor(v Person) error {
	return s.Struct.SetPtr(1, v.Struct.ToPtr())
}

// NewAuthor sets the author field to a newly
// allocated Person struct, preferring placement in s's segment.
func (s Commit) NewAuthor() (Person, error) {
	ss, err := NewPerson(s.Struct.Segment())
	if err != nil {
		return Person{}, err
	}
	err = s.Struct.SetPtr(1, ss.Struct.ToPtr())
	return ss, err
}

func (s Commit) Parent() ([]byte, error) {
	p, err := s.Struct.Ptr(2)
	return []byte(p.Data()), err
}

func (s Commit) HasParent() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s Commit) SetParent(v []byte) error {
	return s.Struct.SetData(2, v)
}

func (s Commit) Root() ([]byte, error) {
	p, err := s.Struct.Ptr(3)
	return []byte(p.Data()), err
}

func (s Commit) HasRoot() bool {
	p, err := s.Struct.Ptr(3)
	return p.IsValid() || err != nil
}

func (s Commit) SetRoot(v []byte) error {
	return s.Struct.SetData(3, v)
}

func (s Commit) Merge() Commit_merge { return Commit_merge(s) }

func (s Commit_merge) IsMerge() bool {
	return s.Struct.Bit(0)
}

func (s Commit_merge) SetIsMerge(v bool) {
	s.Struct.SetBit(0, v)
}

func (s Commit_merge) With() (Person, error) {
	p, err := s.Struct.Ptr(4)
	return Person{Struct: p.Struct()}, err
}

func (s Commit_merge) HasWith() bool {
	p, err := s.Struct.Ptr(4)
	return p.IsValid() || err != nil
}

func (s Commit_merge) SetWith(v Person) error {
	return s.Struct.SetPtr(4, v.Struct.ToPtr())
}

// NewWith sets the with field to a newly
// allocated Person struct, preferring placement in s's segment.
func (s Commit_merge) NewWith() (Person, error) {
	ss, err := NewPerson(s.Struct.Segment())
	if err != nil {
		return Person{}, err
	}
	err = s.Struct.SetPtr(4, ss.Struct.ToPtr())
	return ss, err
}

func (s Commit_merge) Hash() ([]byte, error) {
	p, err := s.Struct.Ptr(5)
	return []byte(p.Data()), err
}

func (s Commit_merge) HasHash() bool {
	p, err := s.Struct.Ptr(5)
	return p.IsValid() || err != nil
}

func (s Commit_merge) SetHash(v []byte) error {
	return s.Struct.SetData(5, v)
}

// Commit_List is a list of Commit.
type Commit_List struct{ capnp.List }

// NewCommit creates a new list of Commit.
func NewCommit_List(s *capnp.Segment, sz int32) (Commit_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 6}, sz)
	return Commit_List{l}, err
}

func (s Commit_List) At(i int) Commit { return Commit{s.List.Struct(i)} }

func (s Commit_List) Set(i int, v Commit) error { return s.List.SetStruct(i, v.Struct) }

func (s Commit_List) String() string {
	str, _ := text.MarshalList(0x8da013c66e545daf, s.List)
	return str
}

// Commit_Promise is a wrapper for a Commit promised by a client call.
type Commit_Promise struct{ *capnp.Pipeline }

func (p Commit_Promise) Struct() (Commit, error) {
	s, err := p.Pipeline.Struct()
	return Commit{s}, err
}

func (p Commit_Promise) Author() Person_Promise {
	return Person_Promise{Pipeline: p.Pipeline.GetPipeline(1)}
}

func (p Commit_Promise) Merge() Commit_merge_Promise { return Commit_merge_Promise{p.Pipeline} }

// Commit_merge_Promise is a wrapper for a Commit_merge promised by a client call.
type Commit_merge_Promise struct{ *capnp.Pipeline }

func (p Commit_merge_Promise) Struct() (Commit_merge, error) {
	s, err := p.Pipeline.Struct()
	return Commit_merge{s}, err
}

func (p Commit_merge_Promise) With() Person_Promise {
	return Person_Promise{Pipeline: p.Pipeline.GetPipeline(4)}
}

// A single directory entry
type DirEntry struct{ capnp.Struct }

// DirEntry_TypeID is the unique identifier for the type DirEntry.
const DirEntry_TypeID = 0x8b15ee76774b1f9d

func NewDirEntry(s *capnp.Segment) (DirEntry, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return DirEntry{st}, err
}

func NewRootDirEntry(s *capnp.Segment) (DirEntry, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return DirEntry{st}, err
}

func ReadRootDirEntry(msg *capnp.Message) (DirEntry, error) {
	root, err := msg.RootPtr()
	return DirEntry{root.Struct()}, err
}

func (s DirEntry) String() string {
	str, _ := text.Marshal(0x8b15ee76774b1f9d, s.Struct)
	return str
}

func (s DirEntry) Name() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s DirEntry) HasName() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s DirEntry) NameBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s DirEntry) SetName(v string) error {
	return s.Struct.SetText(0, v)
}

func (s DirEntry) Hash() ([]byte, error) {
	p, err := s.Struct.Ptr(1)
	return []byte(p.Data()), err
}

func (s DirEntry) HasHash() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s DirEntry) SetHash(v []byte) error {
	return s.Struct.SetData(1, v)
}

// DirEntry_List is a list of DirEntry.
type DirEntry_List struct{ capnp.List }

// NewDirEntry creates a new list of DirEntry.
func NewDirEntry_List(s *capnp.Segment, sz int32) (DirEntry_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return DirEntry_List{l}, err
}

func (s DirEntry_List) At(i int) DirEntry { return DirEntry{s.List.Struct(i)} }

func (s DirEntry_List) Set(i int, v DirEntry) error { return s.List.SetStruct(i, v.Struct) }

func (s DirEntry_List) String() string {
	str, _ := text.MarshalList(0x8b15ee76774b1f9d, s.List)
	return str
}

// DirEntry_Promise is a wrapper for a DirEntry promised by a client call.
type DirEntry_Promise struct{ *capnp.Pipeline }

func (p DirEntry_Promise) Struct() (DirEntry, error) {
	s, err := p.Pipeline.Struct()
	return DirEntry{s}, err
}

// Directory contains one or more directories or files
type Directory struct{ capnp.Struct }

// Directory_TypeID is the unique identifier for the type Directory.
const Directory_TypeID = 0xe24c59306c829c01

func NewDirectory(s *capnp.Segment) (Directory, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Directory{st}, err
}

func NewRootDirectory(s *capnp.Segment) (Directory, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Directory{st}, err
}

func ReadRootDirectory(msg *capnp.Message) (Directory, error) {
	root, err := msg.RootPtr()
	return Directory{root.Struct()}, err
}

func (s Directory) String() string {
	str, _ := text.Marshal(0xe24c59306c829c01, s.Struct)
	return str
}

func (s Directory) Size() uint64 {
	return s.Struct.Uint64(0)
}

func (s Directory) SetSize(v uint64) {
	s.Struct.SetUint64(0, v)
}

func (s Directory) Parent() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Directory) HasParent() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Directory) ParentBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Directory) SetParent(v string) error {
	return s.Struct.SetText(0, v)
}

func (s Directory) Children() (DirEntry_List, error) {
	p, err := s.Struct.Ptr(1)
	return DirEntry_List{List: p.List()}, err
}

func (s Directory) HasChildren() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Directory) SetChildren(v DirEntry_List) error {
	return s.Struct.SetPtr(1, v.List.ToPtr())
}

// NewChildren sets the children field to a newly
// allocated DirEntry_List, preferring placement in s's segment.
func (s Directory) NewChildren(n int32) (DirEntry_List, error) {
	l, err := NewDirEntry_List(s.Struct.Segment(), n)
	if err != nil {
		return DirEntry_List{}, err
	}
	err = s.Struct.SetPtr(1, l.List.ToPtr())
	return l, err
}

// Directory_List is a list of Directory.
type Directory_List struct{ capnp.List }

// NewDirectory creates a new list of Directory.
func NewDirectory_List(s *capnp.Segment, sz int32) (Directory_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return Directory_List{l}, err
}

func (s Directory_List) At(i int) Directory { return Directory{s.List.Struct(i)} }

func (s Directory_List) Set(i int, v Directory) error { return s.List.SetStruct(i, v.Struct) }

func (s Directory_List) String() string {
	str, _ := text.MarshalList(0xe24c59306c829c01, s.List)
	return str
}

// Directory_Promise is a wrapper for a Directory promised by a client call.
type Directory_Promise struct{ *capnp.Pipeline }

func (p Directory_Promise) Struct() (Directory, error) {
	s, err := p.Pipeline.Struct()
	return Directory{s}, err
}

type File struct{ capnp.Struct }

// File_TypeID is the unique identifier for the type File.
const File_TypeID = 0x8ea7393d37893155

func NewFile(s *capnp.Segment) (File, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return File{st}, err
}

func NewRootFile(s *capnp.Segment) (File, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return File{st}, err
}

func ReadRootFile(msg *capnp.Message) (File, error) {
	root, err := msg.RootPtr()
	return File{root.Struct()}, err
}

func (s File) String() string {
	str, _ := text.Marshal(0x8ea7393d37893155, s.Struct)
	return str
}

func (s File) Size() uint64 {
	return s.Struct.Uint64(0)
}

func (s File) SetSize(v uint64) {
	s.Struct.SetUint64(0, v)
}

func (s File) Parent() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s File) HasParent() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s File) ParentBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s File) SetParent(v string) error {
	return s.Struct.SetText(0, v)
}

func (s File) Key() ([]byte, error) {
	p, err := s.Struct.Ptr(1)
	return []byte(p.Data()), err
}

func (s File) HasKey() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s File) SetKey(v []byte) error {
	return s.Struct.SetData(1, v)
}

// File_List is a list of File.
type File_List struct{ capnp.List }

// NewFile creates a new list of File.
func NewFile_List(s *capnp.Segment, sz int32) (File_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return File_List{l}, err
}

func (s File_List) At(i int) File { return File{s.List.Struct(i)} }

func (s File_List) Set(i int, v File) error { return s.List.SetStruct(i, v.Struct) }

func (s File_List) String() string {
	str, _ := text.MarshalList(0x8ea7393d37893155, s.List)
	return str
}

// File_Promise is a wrapper for a File promised by a client call.
type File_Promise struct{ *capnp.Pipeline }

func (p File_Promise) Struct() (File, error) {
	s, err := p.Pipeline.Struct()
	return File{s}, err
}

// Node is a node in the merkle dag of brig
type Node struct{ capnp.Struct }
type Node_Which uint16

const (
	Node_Which_commit    Node_Which = 0
	Node_Which_directory Node_Which = 1
	Node_Which_file      Node_Which = 2
)

func (w Node_Which) String() string {
	const s = "commitdirectoryfile"
	switch w {
	case Node_Which_commit:
		return s[0:6]
	case Node_Which_directory:
		return s[6:15]
	case Node_Which_file:
		return s[15:19]

	}
	return "Node_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Node_TypeID is the unique identifier for the type Node.
const Node_TypeID = 0xa629eb7f7066fae3

func NewNode(s *capnp.Segment) (Node, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 4})
	return Node{st}, err
}

func NewRootNode(s *capnp.Segment) (Node, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 4})
	return Node{st}, err
}

func ReadRootNode(msg *capnp.Message) (Node, error) {
	root, err := msg.RootPtr()
	return Node{root.Struct()}, err
}

func (s Node) String() string {
	str, _ := text.Marshal(0xa629eb7f7066fae3, s.Struct)
	return str
}

func (s Node) Which() Node_Which {
	return Node_Which(s.Struct.Uint16(0))
}
func (s Node) Name() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s Node) HasName() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Node) NameBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s Node) SetName(v string) error {
	return s.Struct.SetText(0, v)
}

func (s Node) Hash() ([]byte, error) {
	p, err := s.Struct.Ptr(1)
	return []byte(p.Data()), err
}

func (s Node) HasHash() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Node) SetHash(v []byte) error {
	return s.Struct.SetData(1, v)
}

func (s Node) ModTime() (string, error) {
	p, err := s.Struct.Ptr(2)
	return p.Text(), err
}

func (s Node) HasModTime() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s Node) ModTimeBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(2)
	return p.TextBytes(), err
}

func (s Node) SetModTime(v string) error {
	return s.Struct.SetText(2, v)
}

func (s Node) Commit() (Commit, error) {
	p, err := s.Struct.Ptr(3)
	return Commit{Struct: p.Struct()}, err
}

func (s Node) HasCommit() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(3)
	return p.IsValid() || err != nil
}

func (s Node) SetCommit(v Commit) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(3, v.Struct.ToPtr())
}

// NewCommit sets the commit field to a newly
// allocated Commit struct, preferring placement in s's segment.
func (s Node) NewCommit() (Commit, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := NewCommit(s.Struct.Segment())
	if err != nil {
		return Commit{}, err
	}
	err = s.Struct.SetPtr(3, ss.Struct.ToPtr())
	return ss, err
}

func (s Node) Directory() (Directory, error) {
	p, err := s.Struct.Ptr(3)
	return Directory{Struct: p.Struct()}, err
}

func (s Node) HasDirectory() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(3)
	return p.IsValid() || err != nil
}

func (s Node) SetDirectory(v Directory) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(3, v.Struct.ToPtr())
}

// NewDirectory sets the directory field to a newly
// allocated Directory struct, preferring placement in s's segment.
func (s Node) NewDirectory() (Directory, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := NewDirectory(s.Struct.Segment())
	if err != nil {
		return Directory{}, err
	}
	err = s.Struct.SetPtr(3, ss.Struct.ToPtr())
	return ss, err
}

func (s Node) File() (File, error) {
	p, err := s.Struct.Ptr(3)
	return File{Struct: p.Struct()}, err
}

func (s Node) HasFile() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(3)
	return p.IsValid() || err != nil
}

func (s Node) SetFile(v File) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(3, v.Struct.ToPtr())
}

// NewFile sets the file field to a newly
// allocated File struct, preferring placement in s's segment.
func (s Node) NewFile() (File, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := NewFile(s.Struct.Segment())
	if err != nil {
		return File{}, err
	}
	err = s.Struct.SetPtr(3, ss.Struct.ToPtr())
	return ss, err
}

// Node_List is a list of Node.
type Node_List struct{ capnp.List }

// NewNode creates a new list of Node.
func NewNode_List(s *capnp.Segment, sz int32) (Node_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 4}, sz)
	return Node_List{l}, err
}

func (s Node_List) At(i int) Node { return Node{s.List.Struct(i)} }

func (s Node_List) Set(i int, v Node) error { return s.List.SetStruct(i, v.Struct) }

func (s Node_List) String() string {
	str, _ := text.MarshalList(0xa629eb7f7066fae3, s.List)
	return str
}

// Node_Promise is a wrapper for a Node promised by a client call.
type Node_Promise struct{ *capnp.Pipeline }

func (p Node_Promise) Struct() (Node, error) {
	s, err := p.Pipeline.Struct()
	return Node{s}, err
}

func (p Node_Promise) Commit() Commit_Promise {
	return Commit_Promise{Pipeline: p.Pipeline.GetPipeline(3)}
}

func (p Node_Promise) Directory() Directory_Promise {
	return Directory_Promise{Pipeline: p.Pipeline.GetPipeline(3)}
}

func (p Node_Promise) File() File_Promise {
	return File_Promise{Pipeline: p.Pipeline.GetPipeline(3)}
}

// Ghost indicates that a certain node was at this path once
type Ghost struct{ capnp.Struct }

// Ghost_TypeID is the unique identifier for the type Ghost.
const Ghost_TypeID = 0x80c828d7e89c12ea

func NewGhost(s *capnp.Segment) (Ghost, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Ghost{st}, err
}

func NewRootGhost(s *capnp.Segment) (Ghost, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Ghost{st}, err
}

func ReadRootGhost(msg *capnp.Message) (Ghost, error) {
	root, err := msg.RootPtr()
	return Ghost{root.Struct()}, err
}

func (s Ghost) String() string {
	str, _ := text.Marshal(0x80c828d7e89c12ea, s.Struct)
	return str
}

func (s Ghost) OldType() uint8 {
	return s.Struct.Uint8(0)
}

func (s Ghost) SetOldType(v uint8) {
	s.Struct.SetUint8(0, v)
}

func (s Ghost) OldNode() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return []byte(p.Data()), err
}

func (s Ghost) HasOldNode() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Ghost) SetOldNode(v []byte) error {
	return s.Struct.SetData(0, v)
}

// Ghost_List is a list of Ghost.
type Ghost_List struct{ capnp.List }

// NewGhost creates a new list of Ghost.
func NewGhost_List(s *capnp.Segment, sz int32) (Ghost_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return Ghost_List{l}, err
}

func (s Ghost_List) At(i int) Ghost { return Ghost{s.List.Struct(i)} }

func (s Ghost_List) Set(i int, v Ghost) error { return s.List.SetStruct(i, v.Struct) }

func (s Ghost_List) String() string {
	str, _ := text.MarshalList(0x80c828d7e89c12ea, s.List)
	return str
}

// Ghost_Promise is a wrapper for a Ghost promised by a client call.
type Ghost_Promise struct{ *capnp.Pipeline }

func (p Ghost_Promise) Struct() (Ghost, error) {
	s, err := p.Pipeline.Struct()
	return Ghost{s}, err
}

const schema_9195d073cb5c5953 = "x\xda\x9cU_h\x1c\xd5\x17>\xe7\xde\xd9\x9d\xf6G" +
	"\xfa\xdb\x9d\xdc\x14,\x18\xe6R*\xa6\xc1\xd4\xa4-\xfe" +
	"\x09\x94\xb45QSS\xc9\xd5\x88\x04\xac0\xdd\xbd\xd9" +
	"\xb9twf\x99\x99\x1aW\x94\xad\xd2\x80Q[\x0cZ" +
	"PHi\x14[\xab\x14B\xc1\x07)\xf8\"T$\xbe" +
	"\x18A\x05\xc1\x87V\x1fD\xc1\x07_\x84@\x1c\xb9\xbb" +
	"\x9b\x9dm\xba\x89\xe2\xe3=sr\xf2}\xdf\xf9\xce\xb7" +
	"\xfd\x17\xc8A2\x90\xaa\x1a\x00b\x7f*\x1d\xff\xda9" +
	"\xff\xcb\xf7=_\x9e\x02\xd1\x89\x18?9\xf9\xccW\xe1" +
	"\xd7\xe7\xe6 \x85&\x00\xbb\x8b|\xce\xfa\x88\xc9\xfa\x88" +
	"\xcd\x14\x99\x06\x8c\xcf\xdb\x8fM?\xf7\xfb\xf6\xd7\xc1\xea" +
	"l\xed&\xba\xfb:\xf9\x81-\x13\x93-\x13\x9b\xad\xd6" +
	"\xba\x17\x8fMx_\xb0\x853\xeb\x87\xa7u\xfb$]" +
	"b\x92\x9aLR{\xdf9j#`\xfc\xd4\xc0\xec\xfd" +
	"\x07\x1e\xfc\xf0\xec\xfa\xfe\xda\xf8Y\xe3\x1a\x9b3L6" +
	"g\xd8\xec\xaa\xb1\x08\x18\xff\xb42U\xae\xfe\xb6\xfb\xd2" +
	"\xba\xf6\x11\xc3\xa4\x00l4u\x8d\x89\x94\xc9D\xca\xde" +
	"7\x93zZ\xcf\xc7\xf9W\x8a\xfd\x93c7\xdb\xce\xff" +
	"6}\x93\xddH\x9b\xecF\xdaf;L=\x7fd\xe6" +
	"\xe2\xd9\xbb\x7f\xbc\xef\xcf\xb6d\xcd%\xb6l\x9al\xd9" +
	"\xb4\xd9\xaa\xa9\xc9.l\xfd\xf8\xd2\xcf\x07\x82\x15\x10;" +
	"\xb0\x85\xfa\xf6\xb4\x89\x9a\xed\x96\x15@vl\xcb\"<" +
	"\x10\xe7\x9c\xb2W\xbe\xb7\xe4\x93\xbc,\xee\xa9=\x06\x1f" +
	"q\xfd0\x82qDa \x89\x9f}\xeb\x82\xf8\xec\xbb" +
	"\xd7\xae\x830\x08\x1e\xba\x07\xb1\x03`\x00\xbf\xc1\xb8\xd6" +
	"\xc6\x95\x97\xce\xab\x9c\x13\xc9\x90G\xae\x13q\x87\xe7d" +
	"\x109\xca\xe3\x9e\x9f\x97|\xda\x09\xb9\x13\xf1\xc8U!" +
	"/;\x91\xcb}/\x87\x12@l\xa1\x06\x80\x81\x00\xd6" +
	"\xee\xc3\x00b\x17E\xd1O\x10\xb1\x0bu\xadO\xd7z" +
	"(\x8a\xfd\x04\xab~1?Q)KL\x03\xc14\xd4" +
	"\xde\x8f\xfby\x89\xdb\x80\xe06\xc0v\x14\x86U0\xe2" +
	"E4\xa8\xb4gqg\x8d\x85\x85K\xf1!\x1e*\xaf" +
	"P\x94\x84\xe7U s\x91\x1fT\xb8\xf4\xa2\xa0\x02\xd8" +
	"\x0a\xb17\x81h51\xf6&\x183\x9eS\x92\xd8\x01" +
	"\x04;\x003\xae\x13\xba\x9b\xa1{\xc8/\x95T\x04\x1b" +
	"H\xcc\x1b\x12\xef\xc4\xb8\xde\xc8\x15\x0d\xb9\xc3C\x19q" +
	"\x7f\x8a\xe7\\\xc7+h\xb5}\xee\xf9f^\x86\x00\xa2" +
	"\xab\x89\xf4%-\xdc\xf3\x14\xc5\xe9\x16\xa4/\x0f\x02\x88" +
	"\x17)\x8aW\x09Z\x84t!\x01\xb0ft\xf1\x14E" +
	"\xf1\x06A\x8b\xd2.\xa4\x00\xd6\xac\xe6t\x9a\xa2x\x93" +
	" \x1a\xd8b$\xeb\xcc^ \xd5\x92\x0cC\xa7\xd0d" +
	":\xe4\x9c\x8c\\?\xc0lbO@\xcc\x02\x0e\x95\x9d" +
	"@z\xd1\x9a\x08\x99\xc0\xf7\x9b\x0f\xbb$\x83\x82l\xea" +
	"\x82k\xba\x0c\x95\x07\x1fVE\xd9^\x94lcc\xff" +
	"\x03\x14\x1dM\xb6#\x1a\xeeA\x8ab,\xb1\xce\xa8\xe6" +
	"5LQ\x8ck\xb2X'{t'\x80x\x94\xa2\x98" +
	" \x98\x09\xd5\x0b\x12\xb7\x02\xc1\xad\x09\xd0\x06!\xf3\x84" +
	"\xac\xdc\xb6\xb9V\x84\xdax\xed\x11\xeej\xac\xed\x08\xc6" +
	"\xba\x89\xab\x90\x1bN\xfd\x08\x94\xc7#W\xf2\x92\x0cN" +
	"\x14%\xcf;\x05\xbd\xc7\xe3\x81*\x00\x8a;\x9ad\xde" +
	"\xd5d\xde\xa6(\x16ZVw^\x17\xdf\xa1(>h" +
	"Y\xdd{z\xc9\xf3\x14\xc5e\x82\xdd4\x8e\x1b\xcb\xbb" +
	"\xa8\x99/P\x14W\x08v\x1b\x7f\xe9\xb2\x01`}\xf4" +
	"\x04\x80\xb8LQ|B\xb0;\xb5\xaa\xcb)\x00\xeb\xaa" +
	"\x9e|\x85\xa2\xf8t3\xfbVK~~B%\x1f\x87" +
	"r5Kb6\x09\x95\xfa\xc6\xe3\xb5\xfb\x01\xac`6" +
	"I\xb7\xfa\xd7\xcc\x94*J\xcc&\xa1\xda\xf8\xa3\xf6\xa7" +
	"+s\x91\xe9ot\xbb=\x0d\x9d\xdf\xc7x\xb8\xf1/" +
	"S\x15\x9e\xf3=\x1d:!\xf7=\xc9\xfd\x80\x97\xfc@" +
	"6OZ\xc9P\xd7\xa6\x94Y\xac\x9d\xcb\x7f1\xd0\x11" +
	"\x001FQ\xb8\x9b\x1b(\xce\xb9\xaa\x98\x0f\xa4\x07\x00" +
	"\xf8\x7f\xc0q\x8a\x98M~\xa9\x00u\xb1\x1d\xedq\x19" +
	"\x84\xbe\xb7Q&\xac\x05\xd6\x1fq\xbd\x8f\x97\x88*\xb8" +
	"\x11?.\xb9\xe3Uj^\xb2\xf9\xc9P\x06\xb7&\xeb" +
	"\xde\x7f\x88-[\xe5[\xb0\xff\xcb\xdc\x1a\xdaS;\xe0" +
	"\xba\x8au\x8b\x8d\x1cNd\xb4\xd0\xa8\x1bl\xb4\xb7U" +
	"\xc7T\x17\xa6\xb5\x8e\xbd\xc9!VUxTOB\x04" +
	"\x82\x08\x98\x99V\x91{{\x96\xdc\x02\xeb\xef\x00\x00\x00" +
	"\xff\xff\xb4\x0a\x04\xec"

func init() {
	schemas.Register(schema_9195d073cb5c5953,
		0x80c828d7e89c12ea,
		0x8b15ee76774b1f9d,
		0x8da013c66e545daf,
		0x8ea7393d37893155,
		0xa629eb7f7066fae3,
		0xe24c59306c829c01,
		0xf736dd278ea58545,
		0xfa723de4a6aa09a0)
}
